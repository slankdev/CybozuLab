
# 知らなかったことまとめ

Feb.3 - Feb.5




## メンバ関数のconstコレクトネス

メソッドをconstで定義すると、そのメソッドないでは、全てのメンバ変数がconstになる。

```
class A {
	int a;
	int b;
	A(int _a, int _b) : a(_a), b(_b) {}
	int func() const {
		return a+b;
	}
};
```

## ケン・プーの「インターフェースの三原則」

 1. インターフェースの実装は、そのメソッドが示すとうりの処理を行わなければならない
 1. インターフェースの実装は、他に危害を加えてはならない。
 1. インターフェースの実装は、自分の責任を果たせない場合、そのことを呼び出し元に伝えなければならない

三つ目の対処方法を以下に示す。

 1. エラーコードを返す (これはc的考えかた)
 1. 例外を投げる (これを採用していきたい)
 1. プログラムを停止する (これは極力さけたい)

エラー報告の方法を一貫させて、ドキュメント化をしておく必要がある



## ドキュメント化について

最小限ドキュメントを見ればうまく使える。サンプルに頼らずに使えるライブラリを設計していきたい。
だが、最低限のドキュメントは必要。そのようなドキュメントの作成方法の手法


## クラス設計

継承は多階層化させないようにする。(多くても2-3くらい)
てことはプロトコルごとのクラスの継承表現は問題があるのではないか。。
is-aは問題ありっぽいので、has-a的な考え方にしますか。。。

### メンバ変数について

プロトコル要素メンバ変数は全てprivate変数にすること。全ての要素に対してsetter, getterを使用して実装する。
***インターフェースをどのようにするかはあとあと考えてもいいので***まずは変数の扱いなどを安定させる。

***アイディア***

メンバ変数を種類ごと(bit長、アドレスやポート)にクラスとして実装して、依存がある要素は特別に優遇させる


### パケットクラスの実装例

```
class packet {
	private:
		/* packet binary datas  */
		/* packet binary length */
	public:
		void*  raw();      /* packet binary datas */
		size_t length();   /* packet binary length */
		bool   correct();  /* is correct packet */
		virtual void summary();
		virtual void info();
		virtual void compile();
};
```



## バイト列の管理をvectorなどの可変長なもので行うようにする。

これはまだノープラン。vectorの使い方すら微妙なので。





## 例外処理

std::exceptionクラスを継承すれば新たに例外クラスを作れる




## コーディング作法

当たり前なことかもしれないが、知らなかったことまとめ。


### コメントの書き方

```
int Func(int arg0, arg1);
```

このような関数のコメントの書き方はこうなる

```
/******************************************
 * Func -- summary...                     *
 *                                        *
 * Arguments                              *
 *     arg0  --  description              *
 *     arg1  --  description              *
 *                                        *
 * Return                                 *
 *     return-variables summary           *
 ******************************************/
```
思ったことだけど、ヘッダファイルうまく書けば、こういうコメントほとんどいらなくなりそう。
いや、コメントはあるだけあったほうがいいのかな。。いやそんなことないか。もうわろた



## 「C++ Coding Standards」を読んで

ネットで良書と書いてあって、それがサイボウズ社の図書としてあったので、よんだ。
この開発で必要と思われることを箇条書きで示す。

 - コンパイルの警告レベルは最高にして開発
 - 実行時エラーより、コンパイル時エラーとリンク時エラーを歓迎しよう
 	- enum 
 	- ダウンキャスト
 - constを積極的に使う
 - なるべく局所変数
 - ***マジックナンバーは避けよう***(心が痛い。。)
 - 一つの関数に一つの仕事
 - どのようなクラスにするかを明確化
 - メンバ変数はprivateメンバにしよう
 - ***内部の情報を公開しない***
 - コンストラクタは代入より、初期化を使え
 - コンストラクタ、デストラクタ内部から仮想関数を呼び出さない
 - 基本クラスのデストラクタはpublic仮想か、protected非仮想にする
 - デストラクタ、リソース解放、swapは決して失敗させない
 - 積極的にassertをしよう(これは別途でassertについていろいろ試そう)
 - エラー通知は例外を使おう
 - 例外は値で投げて参照で捕捉しよう
 - Cスタイルのキャストは使用しない、C++スタイルを使え

関係ないことだが、この本vector好きすぎわろた。(それだけ便利ってことなのかな)


## 「C++実践プログラミング」を読んで

かなり分厚い本だったので、一通りすら見ることもできていないが、"プログラムの設計"のところだけすこし読んだ。

 - 設計目標
	 - 信頼性 (クラッシュしないプログラム。おかしくなったら教える)
	 - 経済性 (これはあたりまえ)
	 - 使いやすさ (機能追加症候群になるな, ドキュメント少し読めば使えるように作れ)
 - 設計要素
	 - 単純さ 
	 - 情報の隠蔽 
	 - 拡張性
	 - テスト可能
	 - 再利用性と凡用性
 - 設計原則
	 - 狙ってから撃て
	 - 撃ってから狙っては当たらない
 - プロシジャとオブジェクトを器用に使い分ける

考えてからコーディングしろ、って書かれてた。はい。悔い改めます。(いままでコード書きながら考えてたからいろいろ
ゴミだった記憶ある。ある程度書く->あ、これここがだめだ, のループでした)


## 設計情報はこうまとめる

各コンポーネントの関係をnamespaceで示す。
その後各コンポーネントのもつクラスなどを分けて列挙していく。
最終的には関数リストまで作成をする。




