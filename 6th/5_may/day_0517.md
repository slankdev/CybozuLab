

## 5/17 (火) 2016

### 今日の予定

 - DPDKアプリケーションでのパケット送信方法の確認 (APIの確認) (3.0h)
 - DPDKアプリケーションの作成の手順をまとめる (2.0h)
 - Libpgenに追加しようと思っていた昨日を追加する (2.0h)



### 今日やった内容

 - [x] DPDKアプリケーションでのパケット送信方法の確認 (APIの確認) (3.0h)
 - [x] レイテンシ計測の準備  (3.0h)
	 - [x] DPDKのパケットフォアードのレイテンシ計測の準備(1.0h)
	 - [x] Linuxカーネルのシステムコールによるパケットフォアードのレイテンシ計測の準備 (2.0h)
 - [x] 作文 (日報を書くのにたくさん時間を使った) (1.0h)
 - [ ] DPDKアプリケーションの作成の手順をまとめる 
 - [ ] Libpgenに追加しようと思っていた昨日を追加する 




### 次回の予定

 - DPDKアプリケーションの作成の手順をまとめる 
 - もっと本格的にレイテンシ計測
 - C++でDPDKを呼び出すときの方法について情報収集
 - 速度計測まで終わったので今後の予定を決める
 - Libpgenに追加しようと思っていた昨日を追加する  (時間が余ったり行き詰まり過ぎたら)




### 問題点,原因,対策 (それぞれ1,2,3で分けて書く)

 1. 借りたマシンでxが起動しなくなった
 2. apt-get update&&apt-get upgradeでなにかおかしくなった
    XorgServer関連の知識が少ないこと。今回で少し勉強になった
 3. 適当にパッケージをインストールし直してたら治った

 1. インターフェースがDPDKにバインドされなくなった
 2. おそらくインターフェース名を伝統的なやつに変更したのが原因 (enpXX -> ethX)
 3. grub.cfgでの起動オプションのbiosdevname, net.ifacesをなくしたところ問題解決

 - 構造体に対するアクセス方法について、こんがらがった。(後述)
 - ドキュメントをうまく使うことについて (後述)

 1. DPDKを使った高速通信のレイテンシは測ったもののどういう意味か分からない。。。
 2. サンプルアプリケーションではパケットを受信したタイミングにタイムスタンプみたいなものを取っておいて、
    そのパケットを送信する時再度タイムスタンプをとってにあらかじめとった奴との差を計算しているので
	時間を表しているのかと思ったが、おそらくCPUのクロックみたいな奴を表している？？
 3. 再起動するごとにリセットしてどんどん増えていくので、起動してからの時間か、総クロック数っぽいことが
    分かった。CPUの動作周波数が3.3GHzなので、それを計算したところおそらく起動してからの
	総クロック数だと思われる。

 1. カーネルのシステムコールでのパケット送信プログラムがずーーーっとうまく動かなかった。。
    DPDKと速度を比較するためにAF_PACKETを使ったパケットフォアードプログラムを書いたのだが、
	パケットの送信はできるものの、受信ができなかった。
 2. 以下に原因のコードを示す。
 ```
 int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL); // こうしなければいけないところを
 int fd = socket(AF_PACKET, SOCK_RAW, htonl(ETH_P_ALL); // こうして書いていた。。
 ```
    要するにhtonl()とhtonsを間違えていただけ。これだけに1,5hも溶かしてしまった。。。。
 3. こういうときは10分くらい休憩してからもう一度考えよう。。そうすれば気づくかもしれないし　




### 感想 (あれば)

今日は結構充実していた気がする。。。


#### DPDKの開発方針

struct rte_mbufでパケットバッファを管理するようなのだが、今までは直接その構造体のメンバに大してアクセスを
していた。例を以下に示す。

```
struct rte_mbuf* bufs[BURST_SIZE];
const uint16_t num_rx = rte_eth_rx_burst(port, 0, bufs, BURST_SIZE);

if (unlikely(num_rx == 0))
    continue;

uint16_t i;
for (i=0; i<num_rx; i++) {
    printf("Received Packet!!! pkt_len=%d \n", bufs[i]->pkt_len);
    hex(bufs[i]->XXXX, bufs[i]->pkt_len); // ここに注目 XXXについては後述
}
```

だがDPDKでは構造体のメンバに対するアクセスの多くにマクロを使用していた。そのように書き直すと以下のようになる。

```
#define 	rte_pktmbuf_mtod_offset(m, t, o)   ((t)((char *)(m)->buf_addr + (m)->data_off + (o)))
#define 	rte_pktmbuf_mtod(m, t)   rte_pktmbuf_mtod_offset(m, t, 0)
```

```
struct rte_mbuf* bufs[BURST_SIZE];
const uint16_t num_rx = rte_eth_rx_burst(port, 0, bufs, BURST_SIZE);

if (unlikely(num_rx == 0))
    continue;

uint16_t i;
for (i=0; i<num_rx; i++) {
    printf("Received Packet!!! pkt_len=%d \n", bufs[i]->pkt_len);
    hex(  rte_pktmbuf_mtod(bufs[i], void*), rte_pktmbuf_pkt_len(bufs[i])  ); // ここに注目
}
```

詳しく覚えていないが、いままでマクロを経由してメンバにアクセスする方法は他のOSSでも見た経験があった
(wiresharkかlinuxカーネルかは忘れた)

***XXXに関して***
rte_mbuf構造体にはdata_offというメンバはユーザから見えず(マクロ展開後のコードを打ち込んでもdata_offは
存在しないとコンパイラにいわれた)ある程度カプセル化をしているかんじだった
前に光成さんにFILE構造体のカプセル化のテクニックについて少し教えてもらっていたので、今回は一応すんなり
理解したつもりになれた。

こういった構文は自己流だけでプログラミングしていても分からないのでやはりOSSソースなど見るのは勉強になるんだ
と再確認した。



#### ドキュメントとAPIリファレンスの使い方

これらをどんな感じに使っていくのかがだんだんと分かってきた気がする。

使うもの(DPDK)の大体の構造を知らないとプログラミングしていくことすらできないので、まずそのようなことを
ドキュメントで学習しておく。それで、実際にコードを書いたり読んだりするときにやりたいことを実現している
マクロや関数をAPIリファレンスで探していく。

今まで最初のドキュメントの需要をあまり考えられていなかった。libpgenの大体の構造は完全に頭の中にあったため。
今後ドキュメント作成が少しやりやすくなりそう。




### Commits

まだサンプルプログラムをごちゃごちゃやってるだけなので、コミットでなくリポジトリを示す。

 - DPDKアプリケーションなどのリポジトリ https://github.com/slankdev/dpdk 
 - 動作テストのアプリケーション https://github.com/slankdev/dpdk/tree/master/myapp



