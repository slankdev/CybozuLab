
# DPDKのパケットフォアードレイテンシ計測


## RDTSC とは

RDTSC(Road Time Stamp Counter)とは起動後のCPUクロックをカウントするカウンタで
相対時刻を計測する時などに使用できる。もっとも制度が高いらしい。
c言語からそのままシステムコールなどで呼び出すことができないので、インラインアセンブラで
rdtsc命令を呼び出して、それをcの変数に入れてCPUクロック数を計測する。

```
#include <stdio.h>
#include <stdint.h>
uint64_t rdtsc() 
{
    unsigned int eax, edx;
	/* 詳しくはintel arch manualググればでます */
    __asm__ volatile("rdtsc" : "=a"(eax), "=d"(edx));
    return ((uint64_t)edx << 32) | eax;
}
```

要は、この関数をパケットのフォワードの前後に入れて、その差分をとれば、
フォワードを初めてから完了するまでに何クロックしたかを知ることができる。
ターボブーストなどをいじっていると、
起動中に勝手にクロック周波数が変わってしまうことがあるので、事前に固定をする必要がある。

linuxカーネルの場合
``/sys/devices/system/cpu/cpufreq/policy{CPU番号}/cpuinfo_{cur, max, min}_freq``
でクロック周波数の現在値、最大値、最小値を知ることができるので、
これらの値を設定してクロック周波数が動的に変更されないように設定してから実験を行う。


## 実験環境の準備

今回のレイテンシ計測は2台のマシン(Master, Slaveとする)を
直接1本のLANケーブルでつないで行う。Master側でパケットフォワードを行うプログラムを動かし、
Slave側からパケットを送信してその時間を計測する。
MasterにはDPDK-16.04をインストールして有効化している。

 - DPDKインストール参考
	 - https://github.com/slankdev/dpdk
	 - http://blog.slankdev.net/2016/05/08/dpdk-setup/


MasterとSlavenのマシンスペックを以下に示す。(ScreenFetchの出力結果を示す。)

 - Master Host
	 - slank@ubuntu
	 - OS: Ubuntu 16.04 xenial
	 - Kernel: x86_64 Linux 4.4.0-22-generic
	 - Uptime: 5h 21m
	 - Packages: 1965
	 - Shell: zsh 5.1.1
	 - Resolution: 3840x1200
	 - WM: XMonad
	 - CPU: Intel Core i7-3930K CPU @ 3.8GHz
	 - GPU: GeForce GT 630
	 - RAM: 3408MiB / 32128MiB
 
 - Slave Host 
	 - slank@localhost
	 - OS: Arch Linux
	 - Kernel: x86_64 Linux 4.5.1-1-ARCH
	 - Uptime: 4h 2m
	 - Packages: 742
	 - Shell: zsh 5.2
	 - Resolution: 1366x768
	 - WM: XMonad
	 - CPU: Intel Core i5-5200U CPU @ 2.7GHz
	 - RAM: 1254MiB / 3835MiB

Masterの怪物マシンはサイボウズ・ラボのPCをお借りしました。
この場を借りてお礼をさせていただきます。ありがとうございました。


## 実験方法1 実験の説明

Master側ではDPDKを使用したフォワードプログラムとLinux KernelのPF_PACKET(以下PF_PACKET)
を使用したフォワードプログラムの2つ使い、動作速度の差を比較していく。

Slave側ではPF_PACKETを使用したパケットの送受信プログラムを用意した。
こちらでもDPDKを使って計測する実験は今後やっていこうと思う。

今回のレイテンシテストの実験は以下の2種類行うこととした。それぞれ、
DPDKとPF_PACKETを使用した方法があるので、全部で4回計測実権を行う。
レイテンシ計測は誤差を少なくするため、10^6パケットを送信して、それぞれのレイテンシの
平均値を計測するものとする。


再度確認だが、Materでパケットフォワードをするアプリケーションを動かし、
SlaveではMasterにパケットを送信して、帰ってくるパケットを受信するプログラムを実効する。



### Latency Test 1

Master側での計測

```
          Slave    Master 
            |        |
            |------->| 受信後
            |        | 
            |<-------| 送信後
            |        | 
            |        |
```

### Latency Test 2

Slave側での計測

```
          Slave    Master 
            |        |
     送信後 |------->| 
            |        | 
     受信後 |<-------| 
            |        | 
            |        |
```

## 実験方法2 使用するプログラム

本実験で使用するプログラムにはLibPGENと筆者が使用する便利関数をまとめたライブラリを使用しているので、
そちらはご了承ください。

 - http://github.com/slankdev/libpgen  パケットのバイナリ生成のため使用
 - http://github.com/slankdev/libslankdev ファイルディスクリプタ処理の簡素化とrdtsc計測のため使用


Slaveで使用するパケット送受信プログラムを以下に示す。

```
```

Masterで動作させるPF_PACKETを使用したパケットフォワードプログラムを以下に示す。

```
```


Masterで動作させるDPDKを使用したパケットフォワードプログラムを以下に示す。

```
```



## 実験結果

先ほど説明した方法で４つのテストを行った。
それぞれ何回ずつか実権を行ってだいたい有意そうな値を以下に示す。

| Index             | 計測場所 |  データプレーン | レイテンシ速度           |
| ----------------- | -------- | --------------- | ------------------------ |
| Latency Test 1.1  | Master   | [DPDK使用]      | 31-34 [clock/packet]     |
| Latency Test 1.2  | Master   | [PF_PACKET使用] | 3000-5000 [clock/packet] |
| Latency Test 2.1  | Slave    | [DPDK使用]      | 3000-6000 [clock/packet] |
| Latency Test 2.2  | Slave    | [PF_PACKET使用] | 3000-6000 [clock/packet] |

Latency Test 1は1000000回パケットを送受信するのにそこまで時間がかからなかったが、
Latency Test 2はTest1と比べ、すこし時間がかかった。Slave側のデータプレーンは
Linux Kernelなため、ある程度パケットをとりきれていない。
(DPDKのエコーの場合早すぎて、ドロップしている？)

Test2はlinux kernelでパケットの送受信をしていることもあり、DPDKレベルの速度は
記録できなかった。




## パケットサイズを大きくした時の結果

## 考察




